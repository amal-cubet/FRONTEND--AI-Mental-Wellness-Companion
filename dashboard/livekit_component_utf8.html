<script src="https://cdn.jsdelivr.net/npm/livekit-client@2.0.7/dist/livekit-client.umd.min.js"></script>

<div id="lk-audio-container" style="display: none;"></div>
<div id="status" class="status-box connecting">
  <div class="spinner"></div>Connecting...
</div>

<div id="transcript" style="display: none; overflow-x: hidden !important; overflow-y: auto !important; width: 100%; max-width: 100%;">
  <div id="transcriptContent" style="overflow-x: hidden !important; width: 100%; max-width: 100%;"></div>
</div>

<script>
let DEEPGRAM_API_KEY = "DEEPGRAM_API_KEY_PLACEHOLDER";
console.log("üîë Deepgram Key loaded:", DEEPGRAM_API_KEY ? DEEPGRAM_API_KEY.substring(0, 8) + "..." : "‚ùå MISSING");

const SHOW_VISIBLE_TRANSCRIPT = false;
let globalRoom = null; // ‚úÖ CRITICAL: This will hold our room reference

// Deepgram STT globals
let dgWs = null;
let mediaStream = null;
let mediaRecorder = null;
let sttActive = false;

const DEEPGRAM_WS_URL = "wss://api.deepgram.com/v1/listen?model=nova-3&punctuate=true&smart_format=true&interim_results=true";

function initializeLiveKit() {
  try {
    const LiveKit = window.LivekitClient || window.LiveKit || window.livekit || window.LiveKitClient;

    if (!LiveKit) {
      console.error("‚ùå LiveKit library not loaded! Check network.");
      return;
    }

    const { Room, RoomEvent, Track, AudioPresets, RoomState } = LiveKit;
    const room = new Room({
      audioOutput: { deviceId: "default" },
      publishDefaults: { audioPreset: AudioPresets.speech },
    });

    globalRoom = room; // ‚úÖ Store room globally for disconnect access

    const url = "LIVEKIT_URL_PLACEHOLDER";
    const token = "LIVEKIT_TOKEN_PLACEHOLDER";
    const statusEl = document.getElementById("status");
    const transcriptContent = document.getElementById("transcriptContent");

    function updateStatus(message, type = "connecting") {
      statusEl.className = `status-box ${type}`;
      statusEl.innerHTML = type === "connecting" ? `<div class="spinner"></div>${message}` : message;
    }

    // === Transcript UI Management ===
    let currentStreamingId = null;
    let currentStreamingSpeaker = null;

    function createNewStreamingElement(speaker) {
      if (currentStreamingId && currentStreamingSpeaker === speaker) {
        const existingElem = document.getElementById(currentStreamingId);
        if (existingElem && !existingElem.dataset.finalized) {
          console.log(`‚ôªÔ∏è Reusing existing ${speaker} bubble`);
          return existingElem;
        }
      }
      if (currentStreamingId) {
        const oldElem = document.getElementById(currentStreamingId);
        if (oldElem && !oldElem.dataset.finalized) {
          const indicator = oldElem.querySelector(".typing-indicator");
          if (indicator) indicator.remove();
          oldElem.classList.remove("streaming");
          oldElem.dataset.finalized = "true";
        }
      }
      const timestamp = Date.now();
      const elem = document.createElement("div");
      elem.id = "streaming-" + speaker + "-" + timestamp;
      elem.className = "transcript-item " + speaker + " streaming";
      elem.dataset.timestamp = timestamp;
      elem.dataset.speaker = speaker;
      elem.innerHTML = `
        <div class="speaker ${speaker}">${speaker === "user" ? "You" : "AI"} <span class="typing-indicator">‚ñã</span></div>
        <div class="streaming-text"></div>`;
      transcriptContent.appendChild(elem);
      currentStreamingId = elem.id;
      currentStreamingSpeaker = speaker;
      console.log(`‚ú® Created NEW ${speaker} bubble:`, elem.id);
      return elem;
    }

    function getCurrentStreamingElement(speaker) {
      if (!currentStreamingId || currentStreamingSpeaker !== speaker) {
        return createNewStreamingElement(speaker);
      }
      const elem = document.getElementById(currentStreamingId);
      if (elem && !elem.dataset.finalized) return elem;
      return createNewStreamingElement(speaker);
    }

    let tokenQueue = [];
    let isProcessingToken = false;

    function updateStreamingText(speaker, token) {
      tokenQueue.push({ speaker, token });
      if (!isProcessingToken) processNextToken();
    }

    function processNextToken() {
      if (tokenQueue.length === 0) {
        isProcessingToken = false;
        return;
      }
      isProcessingToken = true;
      const { speaker, token } = tokenQueue.shift();
      const elem = getCurrentStreamingElement(speaker);
      const textContainer = elem.querySelector(".streaming-text");
      if (!textContainer) {
        processNextToken();
        return;
      }
      textContainer.appendChild(document.createTextNode(token));
      transcriptContent.scrollTop = transcriptContent.scrollHeight;
      setTimeout(processNextToken, 30);
    }

    function finalizeStreamingTranscript(speaker) {
      if (!currentStreamingId) return;
      const streamElem = document.getElementById(currentStreamingId);
      if (streamElem && !streamElem.dataset.finalized) {
        const indicator = streamElem.querySelector(".typing-indicator");
        if (indicator) indicator.remove();
        streamElem.classList.remove("streaming");
        streamElem.dataset.finalized = "true";
        console.log(`‚úÖ Finalized ${speaker} bubble`);
        currentStreamingId = null;
        currentStreamingSpeaker = null;
      }
      transcriptContent.scrollTop = transcriptContent.scrollHeight;
    }

    function updateLiveTranscript(speaker, text) {
      let liveElem = document.getElementById("live-" + speaker);
      if (!liveElem) {
        liveElem = document.createElement("div");
        liveElem.id = "live-" + speaker;
        liveElem.className = "transcript-item " + speaker + " live";
        liveElem.innerHTML = `
          <div class="speaker ${speaker}">${speaker === "user" ? "You" : "AI"}</div>
          <div class="live-text"></div>`;
        transcriptContent.appendChild(liveElem);
      }
      liveElem.querySelector(".live-text").innerText = text;
      transcriptContent.scrollTop = transcriptContent.scrollHeight;
    }

    function removeLiveTranscript(speaker) {
      const liveElem = document.getElementById("live-" + speaker);
      if (liveElem) liveElem.remove();
    }

    // === LiveKit Room Events ===
    room
      .on(RoomEvent.TrackSubscribed, (track) => {
        if (track.kind === Track.Kind.Audio) {
          const audioEl = track.attach();
          audioEl.autoplay = true;
          document.body.appendChild(audioEl);
        }
      })
      .on(RoomEvent.DataReceived, (payload) => {
        try {
          const message = JSON.parse(new TextDecoder("utf-8").decode(payload));
          if (message.type === "ai_stream") {
            updateStreamingText("ai", message.token);
            return;
          }
          switch (message.type) {
            case "user_partial": updateLiveTranscript("user", message.text); break;
            case "partial_ai": updateLiveTranscript("ai", message.text); break;
            case "user_transcript": removeLiveTranscript("user"); break;
            case "ai_transcript": finalizeStreamingTranscript("ai"); break;
          }
        } catch (err) {
          console.error("Data parse error:", err);
        }
      })
      .on(RoomEvent.Connected, () => {
        updateStatus('Connected! Listening... <span class="listening-indicator"></span>', "connected");
        console.log("‚úÖ Room connected, STT will be started externally");
      })
      .on(RoomEvent.Disconnected, () => {
        updateStatus("Disconnected", "error");
        if (sttActive) stopDeepgramSTT();
        console.log("üîå Room disconnected event fired");
      });

    // Connect to room
    setTimeout(async () => {
      try {
        await room.connect(url, token, { autoSubscribe: true, dynacast: true });
        await room.localParticipant.setMicrophoneEnabled(true);
      } catch (error) {
        updateStatus(`Connection Failed: ${error.message}`, "error");
      }
    }, 1000);

    // === Deepgram STT ===
    async function startDeepgramSTT() {
      if (sttActive) {
        console.log("‚ö†Ô∏è STT already active, skipping");
        return;
      }
      console.log("üéß Validating Deepgram key...");
      if (!DEEPGRAM_API_KEY || DEEPGRAM_API_KEY.length < 30) {
        console.error("‚ùå Deepgram key invalid");
        updateStatus("Deepgram key invalid", "error");
        return;
      }
      console.log("‚úÖ Deepgram key validated");
      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (e) {
        console.error("Mic permission error:", e);
        updateStatus("Microphone permission denied", "error");
        return;
      }
      console.log("üîå Connecting to Deepgram...");
      dgWs = new WebSocket(DEEPGRAM_WS_URL, ['token', DEEPGRAM_API_KEY]);
      dgWs.onopen = () => {
        console.log("‚úÖ Deepgram WebSocket connected!");
        sttActive = true;
        updateStatus("Connected + STT Active <span class='listening-indicator'></span>", "connected");
        mediaRecorder = new MediaRecorder(mediaStream, { mimeType: 'audio/webm;codecs=opus' });
        mediaRecorder.addEventListener('dataavailable', async (event) => {
          if (event.data.size > 0 && dgWs.readyState === WebSocket.OPEN) {
            const buffer = await event.data.arrayBuffer();
            dgWs.send(buffer);
          }
        });
        mediaRecorder.start(250);
      };
      dgWs.onmessage = (message) => {
        try {
          const data = JSON.parse(message.data);
          if (data.type === "Metadata") return;
          const alt = data.channel?.alternatives?.[0];
          const transcript = alt?.transcript || "";
          const isFinal = data.is_final || false;
          if (!transcript) return;
          console.log(`üó£Ô∏è ${isFinal ? 'FINAL' : 'interim'}:`, transcript);
          if (!isFinal) {
            updateLiveTranscript("user", transcript);
          } else {
            removeLiveTranscript("user");
            console.log("üìù Creating single user bubble for:", transcript);
            const userBubble = createNewStreamingElement("user");
            const words = transcript.split(/(\s+)/);
            let wordIndex = 0;
            const streamInterval = setInterval(() => {
              if (wordIndex < words.length) {
                const word = words[wordIndex];
                if (word.trim()) {
                  updateStreamingText("user", word + " ");
                }
                wordIndex++;
              } else {
                clearInterval(streamInterval);
                finalizeStreamingTranscript("user");
                if (globalRoom && globalRoom.localParticipant) {
                  const payload = JSON.stringify({
                    type: "user_text_message",
                    text: transcript
                  });
                  globalRoom.localParticipant.publishData(
                    new TextEncoder().encode(payload),
                    { reliable: true }
                  );
                  console.log("üì§ Sent to backend:", transcript.substring(0, 50) + "...");
                }
              }
            }, 60);
          }
        } catch (err) {
          console.warn("DG message parse error:", err);
        }
      };
      dgWs.onerror = (e) => {
        console.error("Deepgram WS error:", e);
        updateStatus("STT WebSocket error", "error");
      };
      dgWs.onclose = () => {
        sttActive = false;
        try { mediaRecorder?.stop(); } catch {}
        mediaStream?.getTracks().forEach(t => t.stop());
        updateStatus("Connected (STT Off)", "connected");
        console.log("üîå Deepgram disconnected");
      };
    }

    function stopDeepgramSTT() {
      try { mediaRecorder?.stop(); } catch {}
      mediaStream?.getTracks().forEach(t => t.stop());
      dgWs?.close();
      sttActive = false;
      updateStatus("Connected (STT Off)", "connected");
    }

    function sendTextMessageToLiveKit(messageText) {
      console.log(`[LiveKit Component] üì© Received message from parent: ${messageText}`);

      if (globalRoom && globalRoom.state === "connected" && globalRoom.localParticipant) {
        try {
          const payload = JSON.stringify({
            type: "user_text_message",
            text: messageText
          });
          globalRoom.localParticipant.publishData(
            new TextEncoder().encode(payload),
            { reliable: true }
          );
          console.log("üì§ [LiveKit Component] Sent text to backend:", messageText.substring(0, 50) + "...");

          removeLiveTranscript("user");
          console.log("üìù Creating single user bubble for:", messageText);
          const userBubble = createNewStreamingElement("user");

          const words = messageText.split(/(\s+)/);
          let wordIndex = 0;

          const streamInterval = setInterval(() => {
            if (wordIndex < words.length) {
              const word = words[wordIndex];
              if (word.trim()) {
                updateStreamingText("user", word + " ");
              }
              wordIndex++;
            } else {
              clearInterval(streamInterval);
              finalizeStreamingTranscript("user");
            }
          }, 60);

          return true;

        } catch (e) {
          console.error("‚ùå [LiveKit Component] Error sending data:", e);
          return false;
        }
      } else {
        const stateInfo = globalRoom ? globalRoom.state : 'null';
        const hasParticipant = globalRoom ? !!globalRoom.localParticipant : 'null';
        console.warn(`‚ö†Ô∏è [LiveKit Component] Cannot send text. Room state: "${stateInfo}", Has Participant: ${hasParticipant}`);
        return false;
      }
    }

    // ============================================
    // üîå DISCONNECT FUNCTION (NEW)
    // ============================================
    async function disconnectRoom() {
      console.log('üî¥ disconnectRoom() called');

      if (!globalRoom) {
        console.warn('‚ö†Ô∏è globalRoom is null');
        return false;
      }

      console.log(`üîç Room state: "${globalRoom.state}"`);

      if (globalRoom.state === 'connected') {
        console.log('‚úÖ Room is connected - disconnecting NOW...');
        try {
          // Stop Deepgram first
          if (sttActive) {
            console.log('üéôÔ∏è Stopping Deepgram STT...');
            stopDeepgramSTT();
          }

          // Disconnect room
          await globalRoom.disconnect();
          console.log('‚úÖ Room disconnected successfully');
          updateStatus("Disconnected", "error");
          return true;
        } catch (error) {
          console.error('‚ùå Error disconnecting room:', error);
          return false;
        }
      } else {
        console.warn(`‚ö†Ô∏è Room not connected (state: ${globalRoom.state})`);
        return false;
      }
    }

    // Expose functions to parent and globally
    if (window.parent && window.parent !== window) {
      window.parent.startDeepgramSTT = startDeepgramSTT;
      window.parent.stopDeepgramSTT = stopDeepgramSTT;
      window.parent.sendTextMessageToLiveKit = sendTextMessageToLiveKit;
      window.parent.disconnectRoom = disconnectRoom; // ‚úÖ NEW
      console.log("‚úÖ [LiveKit Component] Exposed STT, Text, and Disconnect functions to parent.");
    }

    // Also expose locally
    window.startDeepgramSTT = startDeepgramSTT;
    window.stopDeepgramSTT = stopDeepgramSTT;
    window.sendTextMessageToLiveKit = sendTextMessageToLiveKit;
    window.disconnectRoom = disconnectRoom; // ‚úÖ NEW

  } catch (err) {
    console.error("üî• initializeLiveKit() failed:", err);
  }
}

// Call initialization
initializeLiveKit();

</script>

<style>
.status-box{padding:10px;margin-bottom:15px;border-radius:5px;display:flex;align-items:center}
.connecting{background-color:#f0f0f0;color:#333}.connected{background-color:#d4edda;color:#155724}.error{background-color:#f8d7da;color:#721c24}
.spinner{border:3px solid rgba(0,0,0,.1);border-radius:50%;border-top:3px solid #3498db;width:16px;height:16px;animation:spin 1s linear infinite;margin-right:10px}
@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
.listening-indicator{display:inline-block;width:10px;height:10px;background-color:#28a745;border-radius:50%;animation:pulse 1.5s infinite}
@keyframes pulse{0%{opacity:1}50%{opacity:.4}100%{opacity:1}}
.typing-indicator{color:#0066cc;animation:blink 1s infinite}
@keyframes blink{0%,50%{opacity:1}51%,100%{opacity:0}}
#transcriptContent{display:flex;flex-direction:column;justify-content:flex-start;align-items:stretch;overflow-y:auto!important;overflow-x:hidden!important;height:100%;max-height:450px;width:100%;min-width:0;padding:10px 16px;box-sizing:border-box;scroll-behavior:smooth;background-color:#fff;border-radius:10px}
#transcriptContent::-webkit-scrollbar{width:8px}#transcriptContent::-webkit-scrollbar-track{background:#f1f1f1;border-radius:4px}#transcriptContent::-webkit-scrollbar-thumb{background:rgba(120,120,120,.6);border-radius:4px}#transcriptContent::-webkit-scrollbar-thumb:hover{background:rgba(120,120,120,.8)}
.transcript-item{margin-bottom:10px;padding:10px 14px;border-radius:12px;max-width:80%;min-width:0;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;box-sizing:border-box;flex-shrink:1}
.transcript-item.ai{align-self:flex-start;background-color:#f1f1f1;border-left:4px solid #666;color:#333;border-radius:12px 12px 12px 0;margin-right:auto;margin-left:0;width:fit-content}
.transcript-item.user{align-self:flex-end;background-color:#d6ecff;border-left:4px solid #007bff;color:#111;border-radius:12px 12px 0 12px;margin-left:auto;margin-right:0;width:fit-content}
.transcript-item.live{opacity:0.7;font-style:italic}
.speaker{font-weight:700;font-size:.8em;margin-bottom:3px;text-transform:uppercase}.speaker.ai{color:#666}.speaker.user{color:#007bff;text-align:right}
.streaming-text{font-family:'Courier New',Courier,monospace;line-height:1.6;padding:4px;border-radius:3px;background-color:rgba(0,102,204,.05);white-space:pre-wrap!important;word-wrap:break-word;overflow-wrap:break-word}
</style>

<script>
const transcript = document.getElementById('transcriptContent');
if (transcript) {
  const observer = new MutationObserver(() => {
    transcript.scrollTop = transcript.scrollHeight;
  });
  observer.observe(transcript, { childList: true, subtree: true });
}
</script>