<!-- livekit_component_utf8.html - FINAL FIX FOR SPACES -->
<div id="lk-audio-container" style="display: none;"></div>
<div id="status" class="status-box connecting">
  <div class="spinner"></div>Connecting...
</div>

<!-- transcript container (HIDDEN - displayed in Streamlit) -->
<div id="transcript" style="display: none; overflow-x: hidden !important; overflow-y: auto !important; width: 100%; max-width: 100%;">
  <div id="transcriptContent" style="overflow-x: hidden !important; width: 100%; max-width: 100%;"></div>
</div>


<script>
console.log("LiveKit Component: Starting initialization...");

const SHOW_VISIBLE_TRANSCRIPT = false;
let globalRoom = null;

function initializeLiveKit() {
  try {
    console.log("‚úÖ initializeLiveKit() called. Checking LiveKit availability...");
    const LiveKit =
      window.LivekitClient || window.LiveKit || window.livekit || window.LiveKitClient;

    if (!LiveKit) {
      console.error("‚ùå LiveKit library not loaded yet!");
      return;
    }

    const { Room, RoomEvent, Track, AudioPresets } = LiveKit;
    console.log("üì¶ LiveKit components loaded.");

    const room = new Room({
      audioOutput: { deviceId: "default" },
      publishDefaults: { audioPreset: AudioPresets.speech },
    });

    window.globalRoom = room;

    if (window.parent && window.parent !== window) {
      window.parent.globalRoom = room;
    }

    const url = "LIVEKIT_URL_PLACEHOLDER";
    const token = "LIVEKIT_TOKEN_PLACEHOLDER";

    console.log("üîó Connecting to:", url);

    const statusEl = document.getElementById("status");
    const transcriptContent = document.getElementById("transcriptContent");

    function updateStatus(message, type = "connecting") {
      statusEl.className = `status-box ${type}`;
      statusEl.innerHTML =
        type === "connecting" ? `<div class="spinner"></div>${message}` : message;
    }

    // ===== STREAMING TRANSCRIPT FUNCTIONS WITH SPACE FIX =====

    let currentStreamingId = null;
    let currentStreamingSpeaker = null;

    function createNewStreamingElement(speaker) {
      // Finalize any existing streaming element before creating a new one
      if (currentStreamingId) {
        const oldElem = document.getElementById(currentStreamingId);
        if (oldElem && !oldElem.dataset.finalized) {
          console.log("üîí Auto-finalizing old streaming element:", currentStreamingId);
          const indicator = oldElem.querySelector(".typing-indicator");
          if (indicator) indicator.remove();
          oldElem.classList.remove("streaming");
          oldElem.dataset.finalized = "true";
        }
      }

      const timestamp = Date.now();
      const elem = document.createElement("div");
      elem.id = "streaming-" + speaker + "-" + timestamp;
      elem.className = "transcript-item " + speaker + " streaming";
      elem.dataset.timestamp = timestamp;
      elem.dataset.speaker = speaker;
      elem.innerHTML = `
        <div class="speaker ${speaker}">${speaker === "user" ? "You" : "AI"} <span class="typing-indicator">‚ñã</span></div>
        <div class="streaming-text"></div>`;
      transcriptContent.appendChild(elem);
      elem.offsetHeight;

      currentStreamingId = elem.id;
      currentStreamingSpeaker = speaker;
      tokenCounter = 0; // Reset token counter for new message
      console.log("‚úÖ Created new streaming element:", elem.id, "for speaker:", speaker, "(token counter reset)");
      return elem;
    }

    function getCurrentStreamingElement(speaker) {
      // If speaker changed OR no current element OR current is finalized, create new
      if (!currentStreamingId || currentStreamingSpeaker !== speaker) {
        console.log("üÜï Speaker changed or no current element, creating new for:", speaker);
        return createNewStreamingElement(speaker);
      }

      const elem = document.getElementById(currentStreamingId);
      if (elem && !elem.dataset.finalized) {
        return elem;
      }

      console.log("üÜï Current element finalized, creating new for:", speaker);
      return createNewStreamingElement(speaker);
    }

    let tokenQueue = [];
    let isProcessingToken = false;

    let tokenCounter = 0;

    function updateStreamingText(speaker, token) {
      tokenCounter++;
      console.log(`üî∑ [Token #${tokenCounter}] Frontend received token for ${speaker}: '${token}' (len=${token.length})`);
      tokenQueue.push({ speaker, token, tokenNum: tokenCounter });

      if (!isProcessingToken) {
        processNextToken();
      }
    }

    function processNextToken() {
      if (tokenQueue.length === 0) {
        isProcessingToken = false;
        return;
      }

      isProcessingToken = true;
      const { speaker, token, tokenNum } = tokenQueue.shift();

      const elem = getCurrentStreamingElement(speaker);
      const textContainer = elem.querySelector(".streaming-text");

      if (!textContainer) {
        console.error("‚ùå Text container not found in element:", elem.id);
        processNextToken();
        return;
      }

      // ‚úÖ CRITICAL FIX: Use textContent to preserve spaces
      // Create a text node instead of setting innerHTML
      const textNode = document.createTextNode(token);
      const tokenSpan = document.createElement("span");
      tokenSpan.className = "token new-token";
      tokenSpan.appendChild(textNode); // Use appendChild instead of textContent
      textContainer.appendChild(tokenSpan);

      elem.style.display = "block";
      transcriptContent.scrollTop = transcriptContent.scrollHeight;

      console.log(`‚úÖ [Token #${tokenNum}] Displayed token for ${speaker}: '${token}'`);

      setTimeout(() => {
        tokenSpan.className = "token";
        processNextToken();
      }, 50);
    }

    function finalizeStreamingTranscript(speaker) {
      if (!currentStreamingId) {
        console.log("‚ö†Ô∏è No streaming element to finalize");
        return;
      }

      const streamElem = document.getElementById(currentStreamingId);
      if (streamElem && !streamElem.dataset.finalized) {
        console.log("üîí Finalizing streaming element:", currentStreamingId, "for speaker:", speaker);

        const indicator = streamElem.querySelector(".typing-indicator");
        if (indicator) indicator.remove();

        streamElem.classList.remove("streaming");
        streamElem.dataset.finalized = "true";

        // Clear current streaming state
        currentStreamingId = null;
        currentStreamingSpeaker = null;
        console.log("‚úÖ Streaming element finalized and state cleared");
      }

      transcriptContent.scrollTop = transcriptContent.scrollHeight;
    }

    function updateLiveTranscript(speaker, text) {
      let liveElem = document.getElementById("live-" + speaker);
      if (!liveElem) {
        liveElem = document.createElement("div");
        liveElem.id = "live-" + speaker;
        liveElem.className = "transcript-item " + speaker + " live";
        liveElem.innerHTML = `
          <div class="speaker ${speaker}">${speaker === "user" ? "You" : "AI"}</div>
          <div class="live-text"></div>`;
        transcriptContent.appendChild(liveElem);
      }
      liveElem.querySelector(".live-text").innerText = text;
      transcriptContent.scrollTop = transcriptContent.scrollHeight;
    }

    function finalizeTranscript(speaker, text) {
      const liveElem = document.getElementById("live-" + speaker);

      if (liveElem) {
        // Convert live element to final element (no flicker)
        liveElem.classList.remove("live");
        liveElem.id = ""; // Remove live ID
        liveElem.querySelector(".live-text").innerText = text;
        console.log(`‚úÖ Finalized ${speaker} transcript (converted live to final)`);
      } else {
        // Create new final element if no live element exists
        const item = document.createElement("div");
        item.className = "transcript-item " + speaker;
        item.innerHTML = `
          <div class="speaker ${speaker}">${speaker === "user" ? "You" : "AI"}</div>
          <div>${text}</div>`;
        transcriptContent.appendChild(item);
        console.log(`‚úÖ Created new final ${speaker} transcript element`);
      }

      transcriptContent.scrollTop = transcriptContent.scrollHeight;
    }

    // ===== ROOM EVENTS =====
    room
      .on(RoomEvent.TrackSubscribed, (track, publication, participant) => {
        console.log("üéß Track subscribed:", track.kind, participant.identity);
        if (track.kind === Track.Kind.Audio) {
          const audioEl = track.attach();
          audioEl.autoplay = true;
          document.body.appendChild(audioEl);
          console.log("üîä AI audio attached.");
        }
      })
      .on(RoomEvent.DataReceived, (payload) => {
        try {
          const message = JSON.parse(new TextDecoder("utf-8").decode(payload));
          console.log("üì¶ Received data:", message.type);

          if (message.type === "ai_stream") {
            updateStreamingText("ai", message.token);
            return;
          }

          switch (message.type) {
            case "partial_user":
              console.log("üë§ Partial user:", message.text);
              updateLiveTranscript("user", message.text);
              break;

            case "partial_ai":
              console.log("ü§ñ Partial AI:", message.text);
              updateLiveTranscript("ai", message.text);
              break;

            case "user_transcript":
              console.log("üë§ Final user transcript:", message.text);

              // CRITICAL: Finalize any active AI streaming before showing user message
              if (currentStreamingId && currentStreamingSpeaker === "ai") {
                console.log("üîí Auto-finalizing AI stream before user message");
                finalizeStreamingTranscript("ai");
              }

              finalizeTranscript("user", message.text);
              break;

            case "ai_transcript":
              console.log("ü§ñ Final AI transcript:", message.text);
              console.log(`‚è≥ Token queue length at finalization: ${tokenQueue.length}`);

              // Wait a bit if there are still tokens in queue
              if (tokenQueue.length > 0) {
                console.warn(`‚ö†Ô∏è ${tokenQueue.length} tokens still in queue! Waiting before finalization...`);
                setTimeout(() => {
                  console.log("‚úÖ Delayed finalization after queue processed");
                  finalizeStreamingTranscript("ai");
                }, 500);
              } else {
                finalizeStreamingTranscript("ai");
              }
              break;

            default:
              console.log("üìÑ Unknown message:", message);
          }
        } catch (err) {
          console.error("Failed to parse data:", err);
        }
      })
      .on(RoomEvent.Connected, () => {
        console.log("‚úÖ Connected to LiveKit room.");
        updateStatus('Connected! Listening... <span class="listening-indicator"></span>', "connected");
      })
      .on(RoomEvent.Disconnected, () => {
        console.warn("‚ùå Disconnected from room.");
        updateStatus("Disconnected", "error");
      });

    setTimeout(async () => {
      try {
        console.log("üöÄ Attempting connection...");
        await room.connect(url, token, { autoSubscribe: true, dynacast: true });
        console.log("‚úÖ Room connected:", room.state);
        await room.localParticipant.setMicrophoneEnabled(true);
        console.log("üéôÔ∏è Microphone enabled.");
      } catch (error) {
        console.error("‚ùå Connection failed:", error);
        updateStatus(`Connection Failed: ${error.message}`, "error");
      }
    }, 1000);

    window.addEventListener("beforeunload", () => {
      if (room.state === "connected") room.disconnect();
    });
  } catch (err) {
    console.error("üî• initializeLiveKit() failed:", err);
  }
}

window.addEventListener("load", () => {
  console.log("üïê Window loaded - initializing LiveKit");
  initializeLiveKit();
});

window.sendTextMessageToLiveKit = function (message) {
  const room = window.globalRoom;
  if (!room || room.state !== "connected") {
    console.warn("‚ö†Ô∏è Room not ready or disconnected.");
    return false;
  }

  const payload = JSON.stringify({
    type: "user_text_message",
    text: message,
    timestamp: Date.now(),
  });

  room.localParticipant
    .publishData(new TextEncoder().encode(payload), { reliable: true })
    .then(() => console.log("‚úÖ Message sent:", message))
    .catch((err) => console.error("‚ùå Failed to send:", err));

  return true;
};

if (window.parent && window.parent !== window) {
  window.parent.sendTextMessageToLiveKit = window.sendTextMessageToLiveKit;
}
</script>

<!-- Load LiveKit SDK LAST -->
<script src="https://cdn.jsdelivr.net/npm/livekit-client@2.0.7/dist/livekit-client.umd.min.js"></script>

<!-- ===== STYLE WITH SPACE PRESERVATION ===== -->
<style>
/* ===== STATUS & INDICATORS ===== */
.status-box {
  padding: 10px;
  margin-bottom: 15px;
  border-radius: 5px;
  display: flex;
  align-items: center;
}
.connecting { background-color: #f0f0f0; color: #333; }
.connected { background-color: #d4edda; color: #155724; }
.error { background-color: #f8d7da; color: #721c24; }

.spinner {
  border: 3px solid rgba(0, 0, 0, 0.1);
  border-radius: 50%;
  border-top: 3px solid #3498db;
  width: 16px; height: 16px;
  animation: spin 1s linear infinite;
  margin-right: 10px;
}
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

.listening-indicator {
  display: inline-block;
  width: 10px; height: 10px;
  background-color: #28a745;
  border-radius: 50%;
  animation: pulse 1.5s infinite;
}
@keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.4; } 100% { opacity: 1; } }

.typing-indicator {
  color: #0066cc;
  animation: blink 1s infinite;
}
@keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0; } }

/* ===== CHAT CONTAINER ===== */
#transcriptContent {
  display: flex;
  flex-direction: column;
  justify-content: flex-start;     /* start from top */
  align-items: stretch;            /* full width alignment */
  overflow-y: auto !important;
  overflow-x: hidden !important;
  height: 100%;
  max-height: 450px;
  width: 100%;
  min-width: 0;                    /* prevent flex item from growing beyond container */
  padding: 10px 16px;
  box-sizing: border-box;
  scroll-behavior: smooth;
  background-color: #fff;
  border-radius: 10px;
}

#transcriptContent::-webkit-scrollbar {
  width: 8px;
}
#transcriptContent::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}
#transcriptContent::-webkit-scrollbar-thumb {
  background: rgba(120,120,120,0.6);
  border-radius: 4px;
}
#transcriptContent::-webkit-scrollbar-thumb:hover {
  background: rgba(120,120,120,0.8);
}

/* ===== CHAT BUBBLES ===== */
.transcript-item {
  margin-bottom: 10px;
  padding: 10px 14px;
  border-radius: 12px;
  max-width: 80%;
  min-width: 0;
  word-wrap: break-word;
  overflow-wrap: break-word;
  line-height: 1.5;
  box-sizing: border-box;
  flex-shrink: 1;
}

.transcript-item.ai {
  align-self: flex-start;
  background-color: #f1f1f1;
  border-left: 4px solid #666;
  color: #333;
  border-radius: 12px 12px 12px 0;
  margin-right: auto;
  margin-left: 0;
  width: fit-content;
}

.transcript-item.user {
  align-self: flex-end;
  background-color: #d6ecff;
  border-left: 4px solid #007bff;
  color: #111;
  border-radius: 12px 12px 0 12px;
  margin-left: auto;
  margin-right: 0;
  width: fit-content;
}

/* ===== SPEAKER LABELS ===== */
.speaker {
  font-weight: 700;
  font-size: 0.8em;
  margin-bottom: 3px;
  text-transform: uppercase;
}
.speaker.ai {
  color: #666;
}
.speaker.user {
  color: #007bff;
  text-align: right;
}

/* ===== STREAMING TEXT ===== */
.streaming-text {
  font-family: 'Courier New', Courier, monospace;
  line-height: 1.6;
  padding: 4px;
  border-radius: 3px;
  background-color: rgba(0, 102, 204, 0.05);
  white-space: pre-wrap !important;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

.streaming-text .token {
  display: inline !important;
  color: #0066cc;
  font-weight: 600;
  font-size: 1.05em;
  letter-spacing: 0.02em;
  white-space: pre-wrap !important;
}

.streaming-text .new-token {
  display: inline !important;
  color: #0044cc;
  font-weight: 700;
  background-color: rgba(0, 102, 255, 0.15);
  border-radius: 2px;
  animation: pop-in 0.2s ease-out;
}

/* POP-IN EFFECT */
@keyframes pop-in {
  0% { transform: scale(0.8); opacity: 0; }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); opacity: 1; }
}

/* ===== LAYOUT SAFEGUARDS ===== */
* {
  box-sizing: border-box;
}

html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow-x: hidden !important;
  overflow-y: auto;
}

/* Prevent horizontal overflow on main containers */
#transcript, .transcript-container {
  overflow-x: hidden !important;
  width: 100%;
}

/* Proper wrapping for transcript content */
#transcriptContent > * {
  word-wrap: break-word !important;
  overflow-wrap: break-word !important;
}
</style>

<script>
const transcript = document.getElementById('transcriptContent');
if (transcript) {
  const observer = new MutationObserver(() => {
    transcript.scrollTop = transcript.scrollHeight;
  });
  observer.observe(transcript, { childList: true, subtree: true });
}
</script>